#include <stdio.h>
#include <stdbool.h>
#include <malloc.h>
#include <time.h>
#include <stdlib.h>

#include <pgtypes.h>
#include <pgtypes_timestamp.h>
#include <ecpglib.h>
#include <ecpgerrno.h>
#include <sqlca.h>

EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR SQLPRINT;

void CreateLocksTrigger();

void EnsureCreated()
{
    EXEC SQL CREATE TABLE table1 (id serial);

    EXEC SQL CREATE EXTENSION IF NOT EXISTS pgcrypto;

    EXEC SQL CREATE TABLE Accounts
    (
        AccountId            serial PRIMARY KEY,
        Nickname             text      NOT NULL UNIQUE,
        RegistrationDateTime timestamp NOT NULL DEFAULT current_timestamp,
        LoginDateTime        timestamp,
        PasswordHash         text      NOT NULL
    );

    EXEC SQL CREATE TABLE Dialogs
    (
        DialogId serial PRIMARY KEY
    );

    EXEC SQL CREATE TABLE Messages
    (
        MessageId    serial PRIMARY KEY,
        Text         text      NOT NULL,
        SendDateTime timestamp NOT NULL DEFAULT current_timestamp,
        DialogId     int       NOT NULL,
        AuthorId     int       NOT NULL,
        FOREIGN KEY (DialogId) REFERENCES Dialogs (DialogId) ON DELETE CASCADE,
        FOREIGN KEY (AuthorId) REFERENCES Accounts (AccountId) ON DELETE CASCADE
    );

    EXEC SQL CREATE TABLE AccountsDialogs
    (
        AccountId int NOT NULL,
        DialogId  int NOT NULL,
        PRIMARY KEY (AccountId, DialogId),
        FOREIGN KEY (AccountId) REFERENCES Accounts (AccountId) ON DELETE CASCADE,
        FOREIGN KEY (DialogId) REFERENCES Dialogs (DialogId) ON DELETE CASCADE
    );

    EXEC SQL CREATE TABLE Locks
    (
        Name text PRIMARY KEY,
        IsLocked boolean NOT NULL,
        DialogId int NOT NULL,
        FOREIGN KEY (DialogId) REFERENCES Dialogs (DialogId) ON DELETE CASCADE
    );

    CreateLocksTrigger();

    EXEC SQL COMMIT;
}

void Drop()
{
    EXEC SQL DROP TABLE IF EXISTS Locks CASCADE;
    EXEC SQL DROP TABLE IF EXISTS AccountsDialogs CASCADE;
    EXEC SQL DROP TABLE IF EXISTS Messages CASCADE;
    EXEC SQL DROP TABLE IF EXISTS Dialogs CASCADE;
    EXEC SQL DROP TABLE IF EXISTS Accounts CASCADE;
    EXEC SQL DROP TABLE IF EXISTS table1 CASCADE;

    EXEC SQL COMMIT;
}

void Alter()
{
    EXEC SQL ALTER TABLE table1 ADD value int NOT NULL;

    EXEC SQL COMMIT;
}

void AddVal(int val)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int val1 = val;
    EXEC SQL END DECLARE SECTION;
    EXEC SQL INSERT INTO table1 (value) VALUES (:val1);

    EXEC SQL COMMIT;
}

void SelectPrint()
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id = 0;
    int value = 0;
    EXEC SQL END DECLARE SECTION;
    EXEC SQL DECLARE cursor1 CURSOR FOR
        SELECT * FROM table1
        ORDER BY id;
    EXEC SQL OPEN cursor1;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    while (1)
    {
        EXEC SQL FETCH cursor1 INTO :id, :value;
        printf("%d %d\n", id, value);
    }
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL CLOSE cursor1;

    EXEC SQL COMMIT;
}

void Register(char* login, char* password)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* login_ = login;
    char* password_ = password;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO Accounts (Nickname, PasswordHash) VALUES (:login_, crypt(:password_, gen_salt('md5')));

    EXEC SQL COMMIT;
}

bool Login(char* login, char* password)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* login_ = login;
    char* password_ = password;
    bool res = false;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT (PasswordHash = crypt(:password_, PasswordHash)) INTO :res FROM Accounts WHERE Nickname = :login_;

    if (res)
    {
        EXEC SQL UPDATE Accounts SET LoginDateTime = current_timestamp WHERE Nickname = :login_;
    }

    EXEC SQL COMMIT;
    return res;
}

void Lock(char* lockname, int dialogId)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* lockname_ = lockname;
    int dialogId_ = dialogId;
    bool _;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO Locks (Name, IsLocked, DialogId) VALUES (:lockname_, true, :dialogId_);
    EXEC SQL COMMIT;

    EXEC SQL SELECT isLocked INTO :_ FROM Locks WHERE Name = :lockname_ FOR UPDATE;

    //EXEC SQL PREPARE TRANSACTION :lockname_;
    char transaction[256] = "prepare transaction '";
    strcat(transaction, lockname_);
    strcat(transaction, "'");
    ECPGtrans(__LINE__, NULL, transaction);

    EXEC SQL COMMIT;
}

void Wait(char* lockname)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* lockname_ = lockname;
    bool _;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT isLocked INTO :_ FROM Locks WHERE Name = :lockname_ FOR UPDATE;

    EXEC SQL COMMIT;
}

void Unlock(char* lockname)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* lockname_ = lockname;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL COMMIT;

    //EXEC SQL COMMIT PREPARED :lockname_;
    char transaction[256] = "commit prepared '";
    strcat(transaction, lockname_);
    strcat(transaction, "'");
    ECPGtrans(__LINE__, NULL, transaction);

    EXEC SQL COMMIT;

    EXEC SQL UPDATE Locks SET IsLocked = false WHERE Name = :lockname_;

    EXEC SQL COMMIT;
}

void UnlockAll(int dialogId)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int dialogId_ = dialogId;
    char* value;
    int transactionsCount = -1;
    int j = 0;
    char** transactionNames;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT count(*) INTO :transactionsCount FROM locks WHERE DialogId = :dialogId_ AND isLocked = true;

    transactionNames = (char**) malloc (sizeof (char*) * transactionsCount);
    for (int i = 0; i < transactionsCount; i++)
    {
        transactionNames[i] = (char*) malloc (100 * sizeof(char));
    }

    EXEC SQL DECLARE cursor4 CURSOR FOR
        SELECT Name FROM locks WHERE DialogId = :dialogId_ AND isLocked = true;
    EXEC SQL OPEN cursor4;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    while (1)
    {
        EXEC SQL FETCH cursor4 INTO :transactionNames[j++];
    }
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL CLOSE cursor4;

    EXEC SQL COMMIT;

    for (int i = 0; i < transactionsCount; i++)
    {
        Unlock(transactionNames[i]);
    }
}

int CreateDialog(char* name1, char* name2)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* name1_ = name1;
    char* name2_ = name2;
    int dialogId = -1;
    int user1Id = -1;
    int user2Id = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO Dialogs (DialogId) VALUES (DEFAULT) RETURNING dialogid INTO :dialogId;

    EXEC SQL SELECT AccountId INTO :user1Id FROM Accounts WHERE nickname = :name1_;
    EXEC SQL SELECT AccountId INTO :user2Id FROM Accounts WHERE nickname = :name2_;

    EXEC SQL INSERT INTO AccountsDialogs (AccountId, DialogId) VALUES (:user1Id, :dialogId);
    EXEC SQL INSERT INTO AccountsDialogs (AccountId, DialogId) VALUES (:user2Id, :dialogId);

    EXEC SQL COMMIT;
    return dialogId;
}

int GetDialogsCount(char* nickname)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* nickname_ = nickname;
    int userId = -1;
    int count = -1;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT AccountId INTO :userId FROM Accounts WHERE nickname = :nickname_;
    EXEC SQL SELECT count(*) INTO :count FROM AccountsDialogs WHERE AccountId = :userId;

    return count;
}

void GetDialogs(char* nickname, int* outArray)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* nickname_ = nickname;
    int userId = -1;
    int id;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT AccountId INTO :userId FROM Accounts WHERE nickname = :nickname_;

    EXEC SQL DECLARE cursor2 CURSOR FOR
        SELECT DialogId FROM AccountsDialogs WHERE AccountId = :userId ORDER BY DialogId;
    EXEC SQL OPEN cursor2;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    while (1)
    {
        EXEC SQL FETCH cursor2 INTO :id;
        *outArray = id;
        outArray++;
    }
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL CLOSE cursor2;

    EXEC SQL COMMIT;
}

void GetDialogTwoMembers(int dialogId, char* outName1, char* outName2)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int dialogId_ = dialogId;
    char* outName1_ = outName1;
    char* outName2_ = outName2;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL DECLARE cursor3 CURSOR FOR
        SELECT Nickname
        FROM Accounts
            JOIN AccountsDialogs ON Accounts.AccountId = AccountsDialogs.AccountId
        WHERE DialogId = :dialogId_
        ORDER BY Accounts.AccountId;
    EXEC SQL OPEN cursor3;
    EXEC SQL FETCH cursor3 INTO :outName1_;
    EXEC SQL FETCH cursor3 INTO :outName2_;
    EXEC SQL CLOSE cursor3;

    EXEC SQL COMMIT;
}


void SendMessage(int authorId, int dialogId, char* message)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int authorId_ = authorId;
    int dialogId_ = dialogId;
    char* message_ = message;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO Messages (Text, AuthorId, DialogId) VALUES (:message_, :authorId_, :dialogId_);

    EXEC SQL COMMIT;

    UnlockAll(dialogId);
}

int InputLine(char* stringToInput, int maxStringLength)
{
    unsigned long stringLength = 0;
    bool isError = false;
    while (true)
    {
        char* fgetsReturn = fgets(stringToInput, maxStringLength, stdin);
        if (fgetsReturn == NULL)
        {
            return -2;
        }

        stringLength = strlen(stringToInput);

        if (stringToInput[stringLength - 1] != '\n')
        {
            isError = true;
        }
        else
        {
            break;
        }
    }
    if (!isError)
    {
        stringToInput[stringLength - 1] = '\0';
        return (int) stringLength - 1;
    }
    return -1;
}

void StartSendingMessages(int authorId, int dialogId)
{
    while (true)
    {
        printf(" > ");
        fflush(stdout);
        char msg[1000];
        while (InputLine(msg, 1000) <= 0)
        {

        }
        SendMessage(authorId, dialogId, msg);
    }
}

void OutputMessage(char* author, char* message, timestamp time)
{
    char* timestr = PGTYPEStimestamp_to_asc(time);

    printf("%-26s %15s: %s\n", timestr, author, message);
    fflush(stdout);

    PGTYPESchar_free(timestr);
}

void GetPrintMessages(int dialogId, int lastMessages)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int dialogId_ = dialogId;
    int lastMessages_ = lastMessages;
    int offset;
    int count;
    timestamp ts;
    char msg[1000];
    int authorId;
    char name1[100];
    char name2[100];
    int maxAuthorId;
    EXEC SQL END DECLARE SECTION;

    GetDialogTwoMembers(dialogId, name1, name2);
    EXEC SQL SELECT max(AccountId) INTO :maxAuthorId FROM AccountsDialogs WHERE DialogId = :dialogId_;

    if (lastMessages == -1)
    {
        offset = 0;
    }
    else
    {
        EXEC SQL SELECT count(*) INTO :count FROM Messages WHERE DialogId = :dialogId_;
        offset = count - lastMessages;
        offset = offset < 0 ? 0 : offset;
    }

    EXEC SQL DECLARE cursor5 CURSOR FOR
        SELECT Text, SendDateTime, AuthorId FROM Messages
        WHERE DialogId = :dialogId_
        ORDER BY SendDateTime
        OFFSET :offset;
    EXEC SQL OPEN cursor5;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    while (1)
    {
        EXEC SQL FETCH cursor5 INTO :msg, :ts, :authorId;
        OutputMessage(authorId < maxAuthorId ? name1 : name2, msg, ts);
    }
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL CLOSE cursor5;
}


void ReceiveMessage(int dialogId)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int dialogId_ = dialogId;
    char msg[100];
    timestamp sendDateTime;
    int authorId = -1;
    char authorName[100];
    EXEC SQL END DECLARE SECTION;

    timestamp current;
    PGTYPEStimestamp_current(&current);
    char* currentstr = PGTYPEStimestamp_to_asc(current);
    char lockname[100];
    sprintf(lockname, "%s-%d", currentstr, rand());
    PGTYPESchar_free(currentstr);

    Lock(lockname, dialogId);
    Wait(lockname);

    EXEC SQL SELECT Text, SendDateTime, AuthorId
        INTO :msg, :sendDateTime, :authorId
        FROM Messages
        WHERE DialogId = :dialogId_
        ORDER BY SendDateTime DESC
        LIMIT 1;

    EXEC SQL SELECT Nickname INTO :authorName FROM Accounts WHERE AccountId = :authorId;

    OutputMessage(authorName, msg, sendDateTime);

    EXEC SQL COMMIT;
}

void StartReceivingMessages(int dialogId, int lastMessages)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int dialogId_ = dialogId;
    char name1[100];
    char name2[100];
    EXEC SQL END DECLARE SECTION;

    printf("Диалог №%d:\n", dialogId_);

    GetPrintMessages(dialogId, lastMessages);

    while (true)
    {
        ReceiveMessage(dialogId_);
    }
}

void CreateLocksTrigger()
{
    EXEC SQL DROP FUNCTION IF EXISTS clear_old_locks CASCADE;
    EXEC SQL CREATE OR REPLACE FUNCTION clear_old_locks() RETURNS trigger AS
    $$
    BEGIN
        DELETE FROM locks WHERE isLocked = false;
        RETURN NULL;
    END;
    $$ LANGUAGE plpgsql;


    EXEC SQL CREATE TRIGGER clear_old_locks
        BEFORE INSERT
        ON locks
        FOR STATEMENT
    EXECUTE PROCEDURE clear_old_locks();

    EXEC SQL COMMIT;
}

int Connect(char* address, char* port, char* dbname, char* dbUser, char* dbUserPassword)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char target[256] = "";
    char *user_ = dbUser;
    char *password_ = dbUserPassword;
    char *connection = "connection";
    EXEC SQL END DECLARE SECTION;

    strcat(target, "tcp:postgresql://");
    strcat(target, address);
    strcat(target, ":");
    strcat(target, port);
    strcat(target, "/");
    strcat(target, dbname);

    EXEC SQL CONNECT TO :target AS :connection USER :user_ IDENTIFIED BY :password_;
}

int main(int argc, char** argv)
{
    srand(time(NULL));

    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL BEGIN DECLARE SECTION;
    char *target = "tcp:postgresql://localhost:5432/demo";
    char *target1 = "tcp:postgresql://192.168.66.1:5432/demo";
    char *user = "postgres";
    char *password = "qwerty123";
    char *password1 = "zasxcd123";
    char *connection = "connection";
    char *connection1 = "connection1";
    char ver[256];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO :target AS :connection USER :user IDENTIFIED BY :password;
    //EXEC SQL CONNECT TO :target1 AS :connection1 USER :user IDENTIFIED BY :password1;

    EXEC SQL AT :connection SELECT version() INTO :ver;
    printf("version: %s\n", ver);

    //EXEC SQL AT :connection1 SELECT version() INTO :ver;
    //printf("version: %s\n", ver);

    EXEC SQL SET CONNECTION :connection;

    int a;
    scanf("%d", &a);

    if (a == -2)
    {
        printf("Введите IP сервера базы данных [localhost]: ");
        printf("Введите порт сервера базы данных [5432]: ");
        printf("Введите название базы данных [dbmessenger]: ");
        printf("Введите пользователя базы данных [postgres]: ");
        printf("Введите пароль пользователя базы данных [qwerty123]: ");
        printf("Введите логин [User1]: ");
        printf("Введите пароль [qwerty]: ");

    }
    if (a == -1)
    {
        EnsureCreated();
    }
    if (a == 0)
    {
        EnsureCreated();
        Register("qwerty", "123456");
        Register("Vladislav213", "123456");
        CreateDialog("Vladislav213", "qwerty");
    }
    if (a == 1)
    {
        Drop();
    }
    if (a == 2)
    {
        Register("Vladislav213", "123456");
    }
    if (a == 2123)
    {
        Register("qwerty", "123456");
    }
    if (a == 3)
    {
        Login("Vladislav213", "1234516");
    }
    if (a == 10)
    {
        Lock("qwerty5", 1);
    }
    if (a == 11)
    {
        Wait("qwerty5");
    }
    if (a == 12)
    {
        Unlock("lockname");
        Unlock("lockname1");
    }
    if (a == 20)
    {
        Lock("qwerty3", 1);
    }
    if (a == 21)
    {
        Wait("qwerty3");
    }
    if (a == 22)
    {
        Unlock("qwerty3");
    }
    if (a == 30)
    {
        CreateLocksTrigger();
    }
    if (a == 40)
    {
        CreateDialog("Vladislav213", "qwerty");
    }
    if (a == 50)
    {
        int c = GetDialogsCount("Vladislav213");
        int* a = (int*) malloc(c * sizeof(int));
        GetDialogs("Vladislav213", a);
        for (int i = 0; i < c; i++)
        {
            printf("%d ", a[i]);
        }
        free(a);
    }
    if (a == 60)
    {
        char name1[1000];
        char name2[1000];

        GetDialogTwoMembers(1, name1, name2);

        printf("%s %s ", name1, name2);
    }
    if (a == 70)
    {
        timestamp t = PGTYPEStimestamp_from_asc("1999-01-08 04:05:06", NULL);
        OutputMessage("daddad", "dasdasdadad", t);
    }
    if (a == 80)
    {
        SendMessage(1, 1, "message5");
    }
    if (a == 90)
    {
        ReceiveMessage(1);
    }
    if (a == 100)
    {
        StartReceivingMessages(1, 5);
    }
    if (a == 110)
    {
        GetPrintMessages(1, -1);
    }
    if (a == 120)
    {
        StartSendingMessages(1, 1);
    }

    return 0;
}
