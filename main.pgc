#include <stdio.h>
#include <stdbool.h>

#include <pgtypes.h>
#include <ecpglib.h>
#include <ecpgerrno.h>
#include <sqlca.h>

EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR SQLPRINT;

void EnsureCreated()
{
    EXEC SQL CREATE TABLE table1 (id serial);

    EXEC SQL CREATE EXTENSION IF NOT EXISTS pgcrypto;

    EXEC SQL CREATE TABLE Accounts
    (
        AccountId            serial PRIMARY KEY,
        Nickname             text      NOT NULL UNIQUE,
        RegistrationDateTime timestamp NOT NULL DEFAULT current_timestamp,
        LoginDateTime        timestamp,
        PasswordHash         text      NOT NULL
    );

    EXEC SQL CREATE TABLE Dialogs
    (
        DialogId serial PRIMARY KEY
    );

    EXEC SQL CREATE TABLE Messages
    (
        MessageId    serial PRIMARY KEY,
        Text         text      NOT NULL,
        SendDateTime timestamp NOT NULL DEFAULT current_timestamp,
        DialogId     int       NOT NULL,
        AuthorId     int       NOT NULL,
        FOREIGN KEY (DialogId) REFERENCES Dialogs (DialogId) ON DELETE CASCADE,
        FOREIGN KEY (AuthorId) REFERENCES Accounts (AccountId) ON DELETE CASCADE
    );

    EXEC SQL CREATE TABLE AccountsDialogs
    (
        AccountId int NOT NULL,
        DialogId  int NOT NULL,
        PRIMARY KEY (AccountId, DialogId),
        FOREIGN KEY (AccountId) REFERENCES Accounts (AccountId) ON DELETE CASCADE,
        FOREIGN KEY (DialogId) REFERENCES Dialogs (DialogId) ON DELETE CASCADE
    );

    EXEC SQL CREATE TABLE Locks
    (
        Name text PRIMARY KEY,
        IsLocked boolean NOT NULL
    );

    EXEC SQL COMMIT;
}

void Drop()
{
    EXEC SQL DROP TABLE IF EXISTS Locks;
    EXEC SQL DROP TABLE IF EXISTS AccountsDialogs;
    EXEC SQL DROP TABLE IF EXISTS Messages;
    EXEC SQL DROP TABLE IF EXISTS Dialogs;
    EXEC SQL DROP TABLE IF EXISTS Accounts;
    EXEC SQL DROP TABLE IF EXISTS table1;
    EXEC SQL COMMIT;
}

void Alter()
{
    EXEC SQL ALTER TABLE table1 ADD value int NOT NULL;
    EXEC SQL COMMIT;
}

void AddVal(int val)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int val1 = val;
    EXEC SQL END DECLARE SECTION;
    EXEC SQL INSERT INTO table1 (value) VALUES (:val1);
    EXEC SQL COMMIT;
}

void SelectPrint()
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id = 0;
    int value = 0;
    EXEC SQL END DECLARE SECTION;
    EXEC SQL DECLARE cursor1 CURSOR FOR
        SELECT * FROM table1
        ORDER BY id;
    EXEC SQL OPEN cursor1;
    EXEC SQL WHENEVER NOT FOUND DO BREAK;
    while (1)
    {
        EXEC SQL FETCH cursor1 INTO :id, :value;
        printf("%d %d\n", id, value);
    }
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
    EXEC SQL CLOSE cursor1;
    EXEC SQL COMMIT;
}

void NewUser(char* login, char* password)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* login_ = login;
    char* password_ = password;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO Accounts (Nickname, PasswordHash) VALUES (:login_, crypt(:password_, gen_salt('md5')));
    EXEC SQL COMMIT;
}

bool Login(char* login, char* password)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* login_ = login;
    char* password_ = password;
    bool res = false;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT (PasswordHash = crypt(:password_, PasswordHash)) INTO :res FROM Accounts WHERE Nickname = :login_;

    if (res)
    {
        EXEC SQL UPDATE Accounts SET LoginDateTime = current_timestamp WHERE Nickname = :login_;
    }

    EXEC SQL COMMIT;
    return res;
}

void Lock(char* lockname)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* lockname_ = lockname;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO Locks (Name, IsLocked) VALUES (:lockname_, true);
    EXEC SQL COMMIT;

    EXEC SQL SELECT * FROM Locks WHERE Name = :lockname_ FOR UPDATE;

    //EXEC SQL PREPARE TRANSACTION 'qwerty';

    char transaction[256] = "prepare transaction '";
    strcat(transaction, lockname_);
    strcat(transaction, "'");
    ECPGtrans(__LINE__, NULL, transaction);

    EXEC SQL COMMIT;
}

void Wait(char* lockname)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* lockname_ = lockname;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT * FROM Locks WHERE Name = :lockname_ FOR UPDATE;
    EXEC SQL COMMIT;
}

void Unlock(char* lockname)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char* lockname_ = lockname;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL COMMIT;
    //EXEC SQL COMMIT PREPARED 'qwerty2';

    char transaction[256] = "commit prepared '";
    strcat(transaction, lockname_);
    strcat(transaction, "'");
    printf("\n\n%s", transaction);
    ECPGtrans(__LINE__, NULL, transaction);

    EXEC SQL COMMIT;

    EXEC SQL UPDATE Locks SET IsLocked = false WHERE Name = :lockname_;

    EXEC SQL COMMIT;
}

int main(int argc, char** argv)
{
    EXEC SQL WHENEVER NOT FOUND CONTINUE;

    EXEC SQL BEGIN DECLARE SECTION;
    char *target = "tcp:postgresql://localhost:5432/demo";
    char *target1 = "tcp:postgresql://192.168.66.1:5432/demo";
    char *user = "postgres";
    char *password = "qwerty123";
    char *password1 = "zasxcd123";
    char *connection = "connection";
    char *connection1 = "connection1";
    char ver[256];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO :target AS :connection USER :user IDENTIFIED BY :password;
    //EXEC SQL CONNECT TO :target1 AS :connection1 USER :user IDENTIFIED BY :password1;

    EXEC SQL AT :connection SELECT version() INTO :ver;
    printf("version: %s\n", ver);

    //EXEC SQL AT :connection1 SELECT version() INTO :ver;
    //printf("version: %s\n", ver);

    EXEC SQL SET CONNECTION :connection;

    int a;
    scanf("%d", &a);
    printf("%d", a);

    if (a == 0)
    {
        EnsureCreated();
    }
    if (a == 1)
    {
        Drop();
    }
    if (a == 2)
    {
        NewUser("Vladislav213", "123456");
    }
    if (a == 3)
    {
        Login("Vladislav213", "1234516");
    }
    if (a == 10)
    {
        Lock("qwerty5");
    }
    if (a == 11)
    {
        Wait("qwerty5");
    }
    if (a == 12)
    {
        Unlock("qwerty5");
    }
    if (a == 20)
    {
        Lock("qwerty3");
    }
    if (a == 21)
    {
        Wait("qwerty3");
    }
    if (a == 22)
    {
        Unlock("qwerty3");
    }


    return 0;
}
